//NTCU TSCC TEAM , 2015.03
#ifndef DIAGRAM_H
#define DIAGRAM_H
#include "point2f.h"
#include "line2f.h"
#include "MyGLgraphic.h"
#include "color3f.h"
#include <vector>
#include <iostream>

class singlediagram
{
	public:
	std::vector<point2f> points;
	float maxvalue;
	float minvalue;
	int width;		                   //width of singlediagram which display in user intrtface windows
	int height;                        //height of singlediagram which display in user intrtface windows
	int x;			                       //location-x of singlediagram (base on x-axis,y-axis cross point)
	int y;                                  //location-y of singlediagram (base on x-axis,y-axis cross point)
	int display_itemamount; //how many items in values should display on this singlediagram
	int display_startitem;      //which value is the first item display on left of singlediagram
	color3f axiscolor;
	color3f datacolor;

	void setdisplayscope(int Display_itemamount)
	{
		display_startitem = 0;
		display_itemamount = Display_itemamount;
	}

	singlediagram(int X, int Y, int Width, int Height)
	{
		setbound(X, Y, Width, Height);
		setvaluerange(0,100);
		setdisplayscope(100);
	}

	void setbound(int X, int Y, int Width, int Height)
	{
		x = X;
		y = Y;
		width = Width;
		height = Height;
		std::cout<<"x="<<x<<",y="<<y<<",W="<<width<<",H="<<height<<std::endl;
	}

	void setvaluerange(float Minvalue, float Maxvalue)
	{
		maxvalue = Maxvalue;
		minvalue = Minvalue;
		std::cout<<"max="<<maxvalue<<",min="<<minvalue<<std::endl;
	}

	void setdatacolor(color3f Color)
	{
		datacolor.assign(Color);
	}

	void setaxiscolor(color3f Color)
	{
		axiscolor.assign(Color);
	}

	void addvalue(float value)
	{
		float newx,newy;
		point2f newpoint;
		int size=points.size();
		newx=itemnum2pointx(size);
		newy=value2pointy(value);
		newpoint.assign(newx, newy);
		points.push_back(newpoint);
		if(size>display_itemamount)
		{
            display_startitem++;
		}
	}

	void addvalues(float values[],int size)
	{
		for(int i=0 ; i<size ; i++)
			addvalue(values[i]);
	}

	void draw()
	{
		if(width!=0 && height!=0)
		{
            if(points.size()<=display_itemamount)
                draw1();
            else
                draw2();
		}
	}

	void draw1()
	{
        setcolor(datacolor);
        drawpolygon(points);
        setcolor(axiscolor);
        drawline(x,y,x+width,y);
        drawline(x,y,x,y+height);
	}

	void draw2()
	{
        float x_shift = (points.at(display_startitem).x - x);
        setcolor(datacolor);
        drawpolygon(points, -1*x_shift, display_startitem, display_itemamount);
        setcolor(axiscolor);
        drawline(x,y,x+width,y);
        drawline(x,y,x,y+height);
	}

	private:
	float value2pointy(float value)
	{
		if((maxvalue-minvalue)==0)
			return 0;
		if(value>maxvalue || value<minvalue)
			std::cerr<<"uncorrect value "<<value<<std::endl;

		float r = (value-minvalue)/(maxvalue-minvalue);
		float ans =  y+(height)*r;
		std::cout<<"y="<<ans<<std::endl;
		return ans;
	}
	float itemnum2pointx(int itemnum)
	{
		if((display_itemamount-1)<=0)
			return 0;
		float d = ((float)width/(float)(display_itemamount-1))*(float)itemnum;
		float ans = x+d;
		std::cout<<"x="<<ans<<std::endl;
		return ans;
	}

};

#endif
